// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Customer {
  id            String   @id @default(cuid())
  email         String?  @unique
  phone         String?
  name          String
  company       String?
  address       String?
  city          String?
  state         String?
  zipCode       String?
  country       String?
  loyaltyPoints Int      @default(0)
  loyaltyTier   String   @default("bronze") // "bronze", "silver", "gold", "platinum"
  totalSpent    Float    @default(0)
  dueBalance    Float    @default(0)  // Total amount due from customer
  visitCount    Int      @default(0)
  lastVisit     DateTime?
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  sales         Sale[]
  loyaltyTransactions LoyaltyTransaction[]
  customerLoyalty CustomerLoyalty?
  customerLedger CustomerLedger[]
  productReturns ProductReturn[]
}

model Store {
  id          String   @id @default(cuid())
  name        String
  code        String   @unique // Store code for easy reference
  address     String?
  city        String?
  state       String?
  zipCode     String?
  country     String?
  phone       String?
  email       String?
  managerId   String?  @unique
  timezone    String   @default("UTC")
  currency    String   @default("BDT")
  isActive    Boolean  @default(true)
  isHeadquarters Boolean @default(false)
  openingHours String? // JSON string for opening hours
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  manager     User?    @relation("StoreManager", fields: [managerId], references: [id])
  users       UserStore[]
  inventory   Inventory[]
  variationInventories VariationInventory[]
  sales       Sale[]
  purchaseOrders PurchaseOrder[]
  fromTransfers StockTransfer[] @relation("FromStore")
  toTransfers StockTransfer[] @relation("ToStore")
  storeReports StoreReport[]
  stockMovements StockMovement[]
  inventoryAlerts InventoryAlert[]
  storeSettings StoreSettings?
  loyaltyProgram LoyaltyProgram?
  reorderRules ReorderRule[]
  autoOrders  AutoOrder[]
  forecasts   InventoryForecast[]
  audits      InventoryAudit[]
  accounts    Account[]
  bankAccounts BankAccount[]
  expenses    Expense[]
  cashTransactions CashTransaction[]
  invoiceSettings      InvoiceSettings?
  tenantStores  TenantStore[]
  deliveryPersons DeliveryPerson[]
  deliveryAreas  DeliveryArea[]
  deliveryOrders DeliveryOrder[]
  productReturns ProductReturn[]
}

model StoreSettings {
  id        String   @id @default(cuid())
  storeId   String   @unique
  settings  String   // JSON string for all settings
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model UserStore {
  id        String   @id @default(cuid())
  userId    String
  storeId   String
  role      String   @default("staff") // "staff", "manager", "admin"
  isActive  Boolean  @default(true)
  joinedAt  DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, storeId])
}

model StockTransfer {
  id          String   @id @default(cuid())
  transferNumber String @unique
  fromStoreId String
  toStoreId   String
  status      String   @default("pending") // "pending", "approved", "in_transit", "completed", "cancelled"
  transferDate DateTime @default(now())
  expectedDate DateTime?
  completedDate DateTime?
  notes       String?
  requestedBy String
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  fromStore   Store    @relation("FromStore", fields: [fromStoreId], references: [id])
  toStore     Store    @relation("ToStore", fields: [toStoreId], references: [id])
  items       StockTransferItem[]
  stockMovements StockMovement[] @relation("TransferMovement")
}

model StockTransferItem {
  id          String   @id @default(cuid())
  transferId  String
  productId   String
  quantity    Int
  transferredQuantity Int @default(0)
  unitCost    Float
  notes       String?
  createdAt   DateTime @default(now())
  
  transfer    StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product     Product @relation(fields: [productId], references: [id])
}

model ReportSchedule {
  id          String   @id @default(cuid())
  name        String
  description String?
  type        String   // "sales", "inventory", "customer", "employee", "financial", "custom"
  frequency   String   // "daily", "weekly", "monthly", "quarterly", "yearly"
  format      String   // "pdf", "excel", "csv", "json", "email"
  config      String   // JSON string for report configuration
  recipients  String   // JSON array of email addresses
  isActive    Boolean  @default(true)
  timezone    String   @default("UTC")
  nextRun     DateTime?
  lastRun     DateTime?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  reportRuns  ReportRun[]
}

model ReportRun {
  id            String   @id @default(cuid())
  scheduleId    String
  status        String   @default("pending") // "pending", "running", "completed", "failed"
  fileName      String?
  filePath      String?
  fileSize      Int?
  downloadUrl   String?
  errorMessage  String?
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  schedule      ReportSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
}

model ReportTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?
  category    String   // "sales", "inventory", "customer", "employee", "financial", "custom"
  config      String   // JSON string for template configuration
  isDefault   Boolean  @default(false)
  isSystem    Boolean  @default(false)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  reportExports ReportExport[]
}

model ReportExport {
  id          String   @id @default(cuid())
  templateId  String?
  name        String
  type        String   // "sales", "inventory", "customer", "employee", "financial", "custom"
  format      String   // "pdf", "excel", "csv", "json"
  config      String   // JSON string for export configuration
  filters     String?  // JSON string for applied filters
  fileName    String?
  filePath    String?
  fileSize    Int?
  downloadUrl String?
  status      String   @default("pending") // "pending", "processing", "completed", "failed"
  errorMessage String?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  template    ReportTemplate? @relation(fields: [templateId], references: [id])
}

model AutomatedInsight {
  id          String   @id @default(cuid())
  type        String   // "trend", "anomaly", "opportunity", "warning", "recommendation"
  category    String   // "sales", "inventory", "customer", "employee", "financial"
  title       String
  description String
  data        String?  // JSON string with supporting data
  severity    String   @default("medium") // "low", "medium", "high", "critical"
  confidence  Float    @default(0.8) // 0.0 to 1.0
  isRead      Boolean  @default(false)
  isResolved  Boolean  @default(false)
  resolvedAt  DateTime?
  resolvedBy  String?
  actionTaken String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  insightTargets InsightTarget[]
}

model InsightTarget {
  id          String   @id @default(cuid())
  insightId   String
  targetType  String   // "store", "product", "customer", "employee", "category"
  targetId    String
  metadata    String?  // JSON string for additional target data
  createdAt   DateTime @default(now())
  
  insight     AutomatedInsight @relation(fields: [insightId], references: [id], onDelete: Cascade)
}

model DataExport {
  id          String   @id @default(cuid())
  name        String
  type        String   // "sales", "inventory", "customer", "employee", "products", "stores"
  format      String   // "csv", "excel", "json", "xml"
  filters     String?  // JSON string for export filters
  columns     String?  // JSON array of selected columns
  dateRange   String?  // JSON string for date range
  fileName    String?
  filePath    String?
  fileSize    Int?
  downloadUrl String?
  status      String   @default("pending") // "pending", "processing", "completed", "failed"
  errorMessage String?
  progress    Int      @default(0)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model StoreReport {
  id          String   @id @default(cuid())
  storeId     String
  reportType  String   // "daily", "weekly", "monthly", "quarterly", "yearly"
  period      String   // Date range in ISO format
  totalSales  Float    @default(0)
  totalProfit Float    @default(0)
  totalTransactions Int @default(0)
  averageTransaction Float @default(0)
  topProducts String?  // JSON string
  customerMetrics String? // JSON string
  inventoryMetrics String? // JSON string
  generatedAt  DateTime @default(now())
  
  store       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String?
  role          String   @default("staff") // "admin", "staff", "manager", "franchise", "SUPER_ADMIN"
  phone         String?
  address       String?
  city          String?
  state         String?
  zipCode       String?
  country       String?
  hireDate      DateTime?
  birthDate     DateTime?
  department    String?
  position      String?
  salary        Float?
  hourlyRate    Float?
  status        String   @default("active") // "active", "inactive", "on_leave", "terminated"
  employeeId    String?  @unique
  emergencyContact String?
  emergencyPhone String?
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  sales         Sale[]
  timeEntries   TimeEntry[]
  performanceReviews PerformanceReview[]
  performanceReviewsAsReviewer PerformanceReview[] @relation("PerformanceReviews")
  payrollRecords PayrollRecord[]
  stores        UserStore[]
  franchiseUsers FranchiseUser[]
  managedStore  Store?   @relation("StoreManager")
  tenantUsers   TenantUser[]
  productReturns ProductReturn[]
}

model LoyaltyTransaction {
  id          String   @id @default(cuid())
  customerId  String
  points      Int
  type        String   // "earned", "redeemed"
  description String?
  saleId      String?
  createdAt   DateTime @default(now())
  
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  sale        Sale?    @relation(fields: [saleId], references: [id])
}

model Category {
  id            String   @id @default(cuid())
  name          String
  description   String?
  code          String?  // Category code for integration with external systems
  parentId      String?  // For hierarchical structure
  level         Int      @default(1) // 1 = Main Category, 2 = Subcategory, 3 = Sub-subcategory
  hsCode        String?  // Harmonized System Code for international trade
  googleTaxonomyId String? // Google Product Taxonomy ID
  isActive      Boolean  @default(true)
  sortOrder     Int      @default(0) // For ordering categories
  metadata      String?  // JSON string for additional data (attributes, filters, etc.)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  parent        Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      Category[] @relation("CategoryHierarchy")
  products      Product[]
  
  @@unique([name, parentId]) // Ensure unique names within the same parent
}

model Brand {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  logoUrl     String?
  website     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  products    Product[]
}

model GlobalTab {
  id          String   @id @default(cuid())
  name        String
  description String?
  icon        String?
  order       Int      @default(0)
  targetUrl   String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Attribute {
  id          String   @id @default(cuid())
  name        String   @unique
  type        String   // "text", "number", "select", "boolean", "date"
  description String?
  isRequired  Boolean  @default(false)
  isFilterable Boolean @default(true)
  options     String?  // JSON array of options for select type
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  productAttributes ProductAttribute[]
  variationAttributes VariationAttribute[]
}

model ProductAttribute {
  id          String   @id @default(cuid())
  productId   String
  attributeId String
  value       String   // JSON string for complex values
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  
  @@unique([productId, attributeId])
}

model ProductVariation {
  id          String   @id @default(cuid())
  productId   String
  sku         String?  @unique
  barcode     String?
  price       Float
  stock       Int      @default(0)
  imageUrl    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product              @relation(fields: [productId], references: [id], onDelete: Cascade)
  attributes  VariationAttribute[]
  inventory   VariationInventory[]
  saleItems   SaleItem[]
  stockMovements StockMovement[]
  returnItems ReturnItem[]
}

model VariationAttribute {
  id              String   @id @default(cuid())
  variationId     String
  attributeId     String
  attributeValue  String
  
  variation       ProductVariation @relation(fields: [variationId], references: [id], onDelete: Cascade)
  attribute       Attribute        @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  
  @@unique([variationId, attributeId])
}

model VariationInventory {
  id          String   @id @default(cuid())
  variationId String
  storeId     String
  quantity    Int      @default(0)
  minStock    Int      @default(0)
  maxStock    Int?
  reorderPoint Int     @default(0)
  location    String?
  aisle       String?
  shelf       String?
  bin         String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  variation   ProductVariation @relation(fields: [variationId], references: [id], onDelete: Cascade)
  store       Store            @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  @@unique([variationId, storeId])
}

model Badge {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  icon        String?
  color       String   @default("#ffffff")
  backgroundColor String @default("#ff6b6b")
  criteria    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Product {
  id          String   @id @default(cuid())
  name        String
  description String?
  price       Float
  sku         String?  @unique
  barcode     String?  @unique
  categoryId  String?
  brandId     String?
  imageUrl    String?
  isSerialized Boolean  @default(false) // Track if product requires serial numbers
  isBatched   Boolean  @default(false) // Track if product uses batch tracking
  hasVariations Boolean @default(false) // Track if product has variations
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  category    Category? @relation(fields: [categoryId], references: [id])
  brand       Brand?    @relation(fields: [brandId], references: [id])
  inventory   Inventory[]
  saleItems   SaleItem[]
  purchaseOrderItems PurchaseOrderItem[]
  stockMovements StockMovement[]
  inventoryAlerts InventoryAlert[]
  stockTransferItems StockTransferItem[]
  batches     Batch[]
  serialNumbers SerialNumber[]
  reorderRules ReorderRule[]
  forecasts   InventoryForecast[]
  auditItems  InventoryAuditItem[]
  autoOrderItems AutoOrderItem[]
  attributes  ProductAttribute[]
  variations  ProductVariation[]
  ecommerceProducts EcommerceProduct[]
  returnItems ReturnItem[]
}

model Inventory {
  id          String   @id @default(cuid())
  productId   String
  storeId     String
  quantity    Int      @default(0)
  minStock    Int      @default(0)
  maxStock    Int?
  reorderPoint Int     @default(0)
  costPrice   Float    @default(0)
  location    String?
  aisle       String?
  shelf       String?
  bin         String?
  batchNumber String?
  expiryDate  DateTime?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product  @relation(fields: [productId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
  stockMovements StockMovement[]
  inventoryAlerts InventoryAlert[]
  inventoryItems InventoryItem[]
  
  @@unique([productId, storeId])
}

model Supplier {
  id          String   @id @default(cuid())
  name        String
  contactPerson String?
  email       String?
  phone       String?
  address     String?
  city        String?
  state       String?
  zipCode     String?
  country     String?
  website     String?
  taxId       String?
  paymentTerms String?  // "net30", "net60", "cod", etc.
  notes       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  purchaseOrders PurchaseOrder[]
  batches     Batch[]
  reorderRules ReorderRule[]
  autoOrders  AutoOrder[]
  supplierLedger SupplierLedger[]
}

model PurchaseOrder {
  id          String   @id @default(cuid())
  supplierId  String
  storeId     String
  orderNumber String   @unique
  status      String   @default("draft") // "draft", "sent", "confirmed", "partial", "received", "cancelled"
  orderDate   DateTime @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  subtotal    Float    @default(0)
  tax         Float    @default(0)
  shipping    Float    @default(0)
  total       Float    @default(0)
  notes       String?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  supplier    Supplier @relation(fields: [supplierId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
  items       PurchaseOrderItem[]
  stockMovements StockMovement[] @relation("PurchaseOrderMovement")
}

model PurchaseOrderItem {
  id          String   @id @default(cuid())
  purchaseOrderId String
  productId   String
  quantity    Int
  receivedQuantity Int @default(0)
  unitPrice   Float
  totalPrice  Float
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product     Product @relation(fields: [productId], references: [id])
}

model StockMovement {
  id          String   @id @default(cuid())
  productId   String
  variationId String?
  inventoryId  String
  storeId     String
  type        String   // "in", "out", "adjustment", "transfer"
  quantity    Int
  reason      String   // "purchase", "sale", "return", "damage", "theft", "adjustment", "transfer_in", "transfer_out"
  referenceId String?  // saleId, purchaseOrderId, transferId, etc.
  batchId     String?
  serialNumberId String?
  notes       String?
  location    String?
  userId      String?
  createdAt   DateTime @default(now())
  
  product     Product          @relation(fields: [productId], references: [id])
  variation   ProductVariation? @relation(fields: [variationId], references: [id])
  inventory   Inventory        @relation(fields: [inventoryId], references: [id])
  store       Store            @relation(fields: [storeId], references: [id])
  purchaseOrder PurchaseOrder? @relation("PurchaseOrderMovement", fields: [referenceId], references: [id])
  stockTransfer StockTransfer? @relation("TransferMovement", fields: [referenceId], references: [id])
  batch       Batch?           @relation(fields: [batchId], references: [id])
  serialNumber SerialNumber?  @relation(fields: [serialNumberId], references: [id])
  productReturn ProductReturn? @relation("ReturnMovement", fields: [referenceId], references: [id])
}

model InventoryAlert {
  id          String   @id @default(cuid())
  productId   String
  inventoryId  String
  storeId     String
  type        String   // "low_stock", "out_of_stock", "expiring", "overstock"
  severity    String   // "low", "medium", "high", "critical"
  message     String
  isRead      Boolean  @default(false)
  isResolved  Boolean  @default(false)
  resolvedAt  DateTime?
  resolvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product @relation(fields: [productId], references: [id])
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
}

model Sale {
  id          String   @id @default(cuid())
  userId      String
  customerId  String?
  storeId     String
  totalAmount Float
  taxAmount   Float    @default(0)
  discount    Float    @default(0)
  status      String   @default("completed") // "pending", "completed", "cancelled"
  paymentMethod String? // "cash", "card", "mobile"
  customerName String?
  customerEmail String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
  customer    Customer? @relation(fields: [customerId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
  saleItems   SaleItem[]
  payments    Payment[]
  loyaltyTransactions LoyaltyTransaction[]
  deliveryOrder DeliveryOrder?
  serialNumbers SerialNumber[]
  ecommerceOrder EcommerceOrder?
  productReturns ProductReturn[]
}

model SaleItem {
  id          String   @id @default(cuid())
  saleId      String
  productId   String
  variationId String?
  quantity    Int
  unitPrice   Float
  totalPrice  Float
  createdAt   DateTime @default(now())
  
  sale        Sale             @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product     Product          @relation(fields: [productId], references: [id])
  variation   ProductVariation? @relation(fields: [variationId], references: [id])
  returnItems ReturnItem[]
}

model Payment {
  id          String   @id @default(cuid())
  saleId      String
  amount      Float
  method      String   // "cash", "card", "mobile"
  transactionId String?
  createdAt   DateTime @default(now())
  
  sale        Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
}

// Product Return & Refund System
model ProductReturn {
  id            String   @id @default(cuid())
  returnNumber  String   @unique
  saleId        String
  customerId    String?
  storeId       String
  userId        String
  status        String   @default("pending") // "pending", "approved", "rejected", "completed"
  returnDate    DateTime @default(now())
  totalAmount   Float
  taxAmount     Float    @default(0)
  refundAmount  Float
  refundType    String   // "cash", "card", "adjustment", "credit"
  refundStatus  String   @default("pending") // "pending", "processed", "failed"
  restockItems  Boolean  @default(true)
  notes         String?
  approvedBy    String?
  approvedAt    DateTime?
  processedBy   String?
  processedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  sale          Sale             @relation(fields: [saleId], references: [id])
  customer      Customer?        @relation(fields: [customerId], references: [id])
  store         Store            @relation(fields: [storeId], references: [id])
  user          User             @relation(fields: [userId], references: [id])
  returnItems   ReturnItem[]
  returnRefunds ReturnRefund[]
  stockMovements StockMovement[] @relation("ReturnMovement")
}

model ReturnItem {
  id              String   @id @default(cuid())
  returnId        String
  saleItemId      String
  productId       String
  variationId     String?
  quantity        Int
  unitPrice       Float
  totalPrice      Float
  returnReason    String?  // "damaged", "wrong_item", "defective", "changed_mind", "other"
  condition       String   @default("good") // "good", "damaged", "defective"
  restock         Boolean  @default(true)
  notes           String?
  createdAt       DateTime @default(now())
  
  returnProduct   ProductReturn     @relation(fields: [returnId], references: [id], onDelete: Cascade)
  saleItem        SaleItem          @relation(fields: [saleItemId], references: [id])
  product         Product           @relation(fields: [productId], references: [id])
  variation       ProductVariation? @relation(fields: [variationId], references: [id])
}

model ReturnRefund {
  id              String   @id @default(cuid())
  returnId        String
  amount          Float
  method          String   // "cash", "card", "adjustment", "credit"
  transactionId   String?
  processedBy     String
  processedAt     DateTime @default(now())
  notes           String?
  status          String   @default("pending") // "pending", "completed", "failed"
  
  returnProduct   ProductReturn @relation(fields: [returnId], references: [id], onDelete: Cascade)
}

model TimeEntry {
  id          String   @id @default(cuid())
  userId      String
  clockIn     DateTime
  clockOut    DateTime?
  breakStart  DateTime?
  breakEnd    DateTime?
  totalHours  Float?
  overtimeHours Float?
  status      String   @default("active") // "active", "completed", "pending_approval"
  notes       String?
  approvedBy  String?
  approvedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
}

model PerformanceReview {
  id          String   @id @default(cuid())
  userId      String
  reviewerId  String
  reviewDate  DateTime
  period      String   // "monthly", "quarterly", "annual"
  rating      Float    // 1-5 scale
  productivityRating Float?
  customerServiceRating Float?
  teamworkRating Float?
  reliabilityRating Float?
  strengths   String?
  improvements String?
  goals       String?
  comments    String?
  status      String   @default("draft") // "draft", "submitted", "approved", "completed"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
  reviewer    User     @relation("PerformanceReviews", fields: [reviewerId], references: [id])
}

model PayrollRecord {
  id          String   @id @default(cuid())
  userId      String
  period      String   // "weekly", "bi-weekly", "monthly"
  startDate   DateTime
  endDate     DateTime
  regularHours Float
  overtimeHours Float
  regularPay  Float
  overtimePay Float
  bonus       Float?
  deductions  Float?
  taxes       Float?
  netPay      Float
  status      String   @default("pending") // "pending", "processed", "paid"
  paymentDate DateTime?
  paymentMethod String? // "direct_deposit", "check", "cash"
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
}

model LoyaltyProgram {
  id            String   @id @default(cuid())
  storeId       String   @unique
  name          String
  description   String
  isActive      Boolean  @default(true)
  pointsPerDollar Float   @default(1)
  signupBonus   Int      @default(0)
  birthdayBonus Int      @default(0)
  referralBonus Int      @default(0)
  tiers         String   // JSON array of loyalty tiers
  rewards       String   // JSON array of loyalty rewards
  earningRules  String   // JSON array of earning rules
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  store         Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  customerLoyalty CustomerLoyalty[]
}

model CustomerLoyalty {
  id             String   @id @default(cuid())
  customerId     String   @unique
  programId      String
  currentTier    String   @default("bronze")
  totalPoints    Int      @default(0)
  totalEarned    Int      @default(0)
  totalRedeemed  Int      @default(0)
  referralCode   String   @unique
  referralCount  Int      @default(0)
  joinDate       DateTime @default(now())
  lastActivity   DateTime @default(now())
  
  customer       Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)
  program        LoyaltyProgram   @relation(fields: [programId], references: [id])
  loyaltyRewards LoyaltyReward[]
  pointExpirations PointExpiration[]
}

model LoyaltyReward {
  id            String   @id @default(cuid())
  customerLoyaltyId String
  name          String
  description   String
  type          String   // "discount", "free_item", "cashback", "experience"
  value         Float
  pointsRequired Int
  isRedeemed    Boolean  @default(false)
  redeemedAt    DateTime?
  expiresAt     DateTime?
  createdAt     DateTime @default(now())
  
  customerLoyalty CustomerLoyalty @relation(fields: [customerLoyaltyId], references: [id], onDelete: Cascade)
}

model PointExpiration {
  id            String   @id @default(cuid())
  customerLoyaltyId String
  points        Int
  expiresAt     DateTime
  isExpired     Boolean  @default(false)
  createdAt     DateTime @default(now())
  
  customerLoyalty CustomerLoyalty @relation(fields: [customerLoyaltyId], references: [id], onDelete: Cascade)
}

// Advanced Inventory Management Models
model Batch {
  id          String   @id @default(cuid())
  productId   String
  batchNumber String   @unique
  quantity    Int      @default(0)
  manufacturedDate DateTime?
  expiryDate  DateTime?
  costPrice   Float    @default(0)
  supplierId  String?
  notes       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product  @relation(fields: [productId], references: [id])
  supplier    Supplier? @relation(fields: [supplierId], references: [id])
  serialNumbers SerialNumber[]
  inventoryItems InventoryItem[]
  stockMovements StockMovement[]
}

model SerialNumber {
  id          String   @id @default(cuid())
  productId   String
  batchId     String?
  serialNumber String   @unique
  status      String   @default("available") // "available", "sold", "returned", "damaged", "expired"
  costPrice   Float    @default(0)
  saleId      String?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product  @relation(fields: [productId], references: [id])
  batch       Batch?   @relation(fields: [batchId], references: [id])
  sale        Sale?    @relation(fields: [saleId], references: [id])
  inventoryItem InventoryItem?
  stockMovements StockMovement[]
}

model InventoryItem {
  id          String   @id @default(cuid())
  inventoryId String
  batchId     String?
  serialNumberId String? @unique
  quantity    Int      @default(1)
  location    String?
  aisle       String?
  shelf       String?
  bin         String?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  batch       Batch?    @relation(fields: [batchId], references: [id])
  serialNumber SerialNumber? @relation(fields: [serialNumberId], references: [id])
}

model ReorderRule {
  id          String   @id @default(cuid())
  productId   String
  storeId     String
  ruleType    String   @default("quantity") // "quantity", "days", "percentage"
  triggerValue Float   @default(0)
  orderQuantity Int    @default(0)
  supplierId  String?
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product  @relation(fields: [productId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
  supplier    Supplier? @relation(fields: [supplierId], references: [id])
  autoOrders  AutoOrder[]
}

model AutoOrder {
  id          String   @id @default(cuid())
  reorderRuleId String
  supplierId  String
  storeId     String
  status      String   @default("pending") // "pending", "sent", "confirmed", "received", "cancelled"
  orderDate   DateTime @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  totalAmount Float    @default(0)
  notes       String?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  reorderRule ReorderRule @relation(fields: [reorderRuleId], references: [id])
  supplier    Supplier @relation(fields: [supplierId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
  items       AutoOrderItem[]
}

model AutoOrderItem {
  id          String   @id @default(cuid())
  autoOrderId String
  productId   String
  quantity    Int
  unitPrice   Float
  totalPrice  Float
  receivedQuantity Int @default(0)
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  autoOrder   AutoOrder @relation(fields: [autoOrderId], references: [id], onDelete: Cascade)
  product     Product @relation(fields: [productId], references: [id])
}

model InventoryForecast {
  id          String   @id @default(cuid())
  productId   String
  storeId     String
  forecastType String  // "demand", "trend", "seasonal", "custom"
  period      String   // Date range in ISO format
  forecastData String  // JSON string with forecast data
  confidence  Float    @default(0.8) // 0.0 to 1.0
  accuracy    Float?   // Historical accuracy percentage
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  product     Product  @relation(fields: [productId], references: [id])
  store       Store    @relation(fields: [storeId], references: [id])
}

model InventoryAudit {
  id          String   @id @default(cuid())
  storeId     String
  auditNumber String   @unique
  auditDate   DateTime @default(now())
  status      String   @default("pending") // "pending", "in_progress", "completed", "cancelled"
  auditedBy   String?
  notes       String?
  discrepancies String? // JSON string with audit discrepancies
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  store       Store    @relation(fields: [storeId], references: [id])
  items       InventoryAuditItem[]
}

model InventoryAuditItem {
  id          String   @id @default(cuid())
  auditId     String
  productId   String
  expectedQuantity Int
  actualQuantity Int
  variance    Int
  varianceReason String?
  notes       String?
  createdAt   DateTime @default(now())
  
  audit       InventoryAudit @relation(fields: [auditId], references: [id], onDelete: Cascade)
  product     Product @relation(fields: [productId], references: [id])
}

// Accounts Management Module
model Account {
  id          String   @id @default(cuid())
  name        String
  type        String   // "asset", "liability", "equity", "revenue", "expense"
  subtype     String?  // "bank", "cash", "accounts_receivable", "accounts_payable", "income", "operating_expense", etc.
  accountNumber String? @unique
  description String?
  isActive    Boolean  @default(true)
  balance     Float    @default(0)
  currency    String   @default("BDT")
  storeId     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  store       Store?   @relation(fields: [storeId], references: [id])
  transactions AccountTransaction[]
  bankAccount BankAccount?
}

model AccountTransaction {
  id          String   @id @default(cuid())
  accountId   String
  type        String   // "debit", "credit"
  amount      Float
  description String?
  referenceId String?  // Reference to sale, purchase, expense, etc.
  referenceType String? // "sale", "purchase_order", "expense", "payment", "bank_transfer"
  date        DateTime @default(now())
  createdBy   String
  createdAt   DateTime @default(now())
  
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model BankAccount {
  id          String   @id @default(cuid())
  accountId   String   @unique
  bankName    String
  accountNumber String
  accountType String   // "checking", "savings", "business"
  branchName  String?
  routingNumber String?
  swiftCode   String?
  iban        String?
  balance     Float    @default(0)
  currency    String   @default("BDT")
  isActive    Boolean  @default(true)
  storeId     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  store       Store?   @relation(fields: [storeId], references: [id])
  bankTransactions BankTransaction[]
}

model BankTransaction {
  id          String   @id @default(cuid())
  bankAccountId String
  type        String   // "deposit", "withdrawal", "transfer"
  amount      Float
  description String?
  reference   String?
  transactionDate DateTime @default(now())
  balance     Float
  createdBy   String
  createdAt   DateTime @default(now())
  
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
}

model CustomerLedger {
  id          String   @id @default(cuid())
  customerId  String
  type        String   // "sale", "payment", "credit_note", "debit_note"
  amount      Float
  balance     Float    @default(0)
  description String?
  referenceId String?  // Reference to sale, payment, etc.
  date        DateTime @default(now())
  createdBy   String
  createdAt   DateTime @default(now())
  
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model SupplierLedger {
  id          String   @id @default(cuid())
  supplierId  String
  type        String   // "purchase", "payment", "credit_note", "debit_note"
  amount      Float
  balance     Float    @default(0)
  description String?
  referenceId String?  // Reference to purchase order, payment, etc.
  date        DateTime @default(now())
  createdBy   String
  createdAt   DateTime @default(now())
  
  supplier    Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
}

model Expense {
  id          String   @id @default(cuid())
  categoryId  String
  amount      Float
  description String
  date        DateTime @default(now())
  paymentMethod String // "cash", "bank_transfer", "credit_card", "check"
  status      String   @default("pending") // "pending", "approved", "paid", "rejected"
  approvedBy  String?
  paidAt      DateTime?
  receiptUrl  String?
  notes       String?
  storeId     String?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  category    ExpenseCategory @relation(fields: [categoryId], references: [id])
  store       Store?   @relation(fields: [storeId], references: [id])
  expenseItems ExpenseItem[]
}

model ExpenseCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  expenses    Expense[]
}

model ExpenseItem {
  id          String   @id @default(cuid())
  expenseId   String
  description String
  amount      Float
  quantity    Int      @default(1)
  createdAt   DateTime @default(now())
  
  expense     Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
}

model CashTransaction {
  id          String   @id @default(cuid())
  type        String   // "income", "expense"
  amount      Float
  description String
  referenceId String?  // Reference to sale, expense, etc.
  referenceType String? // "sale", "expense", "payment"
  date        DateTime @default(now())
  balance     Float
  storeId     String?
  createdBy   String
  createdAt   DateTime @default(now())
  
  store       Store?   @relation(fields: [storeId], references: [id])
}

model DueReport {
  id          String   @id @default(cuid())
  type        String   // "receivable", "payable"
  entityId    String   // Customer ID or Supplier ID
  entityName  String
  totalAmount Float
  paidAmount  Float    @default(0)
  dueAmount   Float
  dueDate     DateTime?
  status      String   @default("pending") // "pending", "partial", "paid", "overdue"
  lastUpdated DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// License Management System
model License {
  id              String   @id @default(cuid())
  licenseKey      String   @unique
  type            String   // "lifetime", "monthly", "yearly"
  status          String   @default("active") // "active", "expired", "suspended", "cancelled"
  clientId        String   // Client identifier (company name or email)
  clientEmail     String
  clientName      String
  franchiseId     String?  // Link to franchise if this is a franchise client
  franchiseClientId String? // Link to franchise client if this is a franchise client
  maxUsers        Int      @default(1)
  maxStores       Int      @default(1)
  allowedDomains  String?  // JSON array of allowed domains
  hardwareBinding String?  // JSON object with hardware identifiers
  activationCount Int      @default(0)
  maxActivations  Int      @default(3)
  issuedAt       DateTime @default(now())
  expiresAt       DateTime?
  lastActivatedAt DateTime?
  lastVerifiedAt  DateTime?
  notes           String?
  createdBy       String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  activations     LicenseActivation[]
  payments        LicensePayment[]
  franchise       Franchise? @relation(fields: [franchiseId], references: [id])
  franchiseClient FranchiseClient? @relation(fields: [franchiseClientId], references: [id])
  tenantLicenses  TenantLicense[]
}

model LicenseActivation {
  id              String   @id @default(cuid())
  licenseId       String
  activationKey   String   @unique
  domain          String?
  hardwareId      String?
  ipAddress       String?
  isActive        Boolean  @default(true)
  activatedAt     DateTime @default(now())
  lastVerifiedAt  DateTime?
  deactivatedAt   DateTime?
  deactivationReason String?
  
  license         License  @relation(fields: [licenseId], references: [id], onDelete: Cascade)
}

model LicensePayment {
  id              String   @id @default(cuid())
  licenseId       String
  amount          Float
  currency        String   @default("USD")
  paymentMethod   String   // "stripe", "paypal", "bank_transfer", "manual"
  transactionId   String?
  status          String   @default("completed") // "pending", "completed", "failed", "refunded"
  periodStart     DateTime
  periodEnd       DateTime?
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  license         License  @relation(fields: [licenseId], references: [id], onDelete: Cascade)
}

// Franchise Management System
model Franchise {
  id                    String   @id @default(cuid())
  name                  String
  email                 String   @unique
  phone                 String?
  address               String?
  city                  String?
  state                 String?
  zipCode               String?
  country               String?
  website               String?
  contactPerson         String?
  businessLicense       String?
  taxId                 String?
  status                String   @default("pending") // "pending", "approved", "active", "suspended", "rejected"
  oneTimeFee            Float    @default(20.00)
  monthlyFee            Float    @default(5.00)
  contractStart         DateTime?
  contractEnd           DateTime?
  maxClients            Int      @default(50)
  currentClients        Int      @default(0)
  totalRevenue          Float    @default(0)
  outstandingBalance    Float    @default(0)
  isBlocked             Boolean  @default(false)
  blockReason           String?
  notes                 String?
  approvedBy            String?
  approvedAt            DateTime?
  createdBy             String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  users                 FranchiseUser[]
  clients               FranchiseClient[]
  royaltyPayments       RoyaltyPayment[]
  licenses              License[]
}

model FranchiseUser {
  id                    String   @id @default(cuid())
  franchiseId           String
  userId                String
  role                  String   @default("admin") // "admin", "manager", "staff"
  permissions           String?  // JSON string for custom permissions
  isActive              Boolean  @default(true)
  joinedAt              DateTime @default(now())
  
  franchise             Franchise @relation(fields: [franchiseId], references: [id], onDelete: Cascade)
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([franchiseId, userId])
}

model FranchiseClient {
  id                    String   @id @default(cuid())
  franchiseId           String
  clientId              String
  clientName            String
  clientEmail           String
  clientPhone           String?
  clientCompany         String?
  status                String   @default("pending") // "pending", "approved", "active", "suspended"
  oneTimeFeePaid        Boolean  @default(false)
  monthlyFeePaid        Boolean  @default(false)
  lastPaymentDate       DateTime?
  nextPaymentDate       DateTime?
  totalPaid             Float    @default(0)
  notes                 String?
  approvedBy            String?
  approvedAt            DateTime?
  createdBy             String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  franchise             Franchise @relation(fields: [franchiseId], references: [id], onDelete: Cascade)
  licenses              License[]
  royaltyPayments       RoyaltyPayment[]
}

model RoyaltyPayment {
  id                    String   @id @default(cuid())
  franchiseId           String
  clientId              String?
  amount                Float
  currency              String   @default("USD")
  paymentType           String   // "one_time", "monthly", "adjustment", "penalty"
  status                String   @default("pending") // "pending", "paid", "overdue", "cancelled"
  dueDate               DateTime
  paidDate              DateTime?
  paymentMethod         String?  // "stripe", "paypal", "bank_transfer", "manual"
  transactionId         String?
  notes                 String?
  createdBy             String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  franchise             Franchise @relation(fields: [franchiseId], references: [id], onDelete: Cascade)
  client                FranchiseClient? @relation(fields: [clientId], references: [id], onDelete: Cascade)
}

model InvoiceSettings {
  id                    String   @id @default(cuid())
  storeId               String?  // Optional: null for global settings
  businessInfo          String   // JSON string for business information
  receiptSettings       String   // JSON string for receipt settings
  labels                String   // JSON string for label settings
  printSettings         String   // JSON string for print settings
  displaySettings       String   // JSON string for display settings
  isActive              Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  store                 Store?    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  @@unique([storeId])
}

// Multi-Tenant System Models
model Tenant {
  id                    String   @id @default(cuid())
  name                  String
  email                 String   @unique
  plan                  String   @default("basic") // "basic", "professional", "enterprise"
  maxUsers              Int      @default(5)
  maxStores             Int      @default(1)
  customDomain          Boolean  @default(false)
  settings              String   // JSON string for tenant settings
  isActive              Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  domains               TenantDomain[]
  users                 TenantUser[]
  stores                TenantStore[]
  licenses              TenantLicense[]
  subscriptions         Subscription[]
}

model TenantDomain {
  id                    String   @id @default(cuid())
  tenantId              String
  domain                String   @unique
  isPrimary             Boolean  @default(false)
  isVerified            Boolean  @default(false)
  sslEnabled            Boolean  @default(false)
  dnsRecord             String?
  verificationToken     String
  verifiedAt            DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  tenant                Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

model TenantUser {
  id                    String   @id @default(cuid())
  tenantId              String
  userId                String
  role                  String   @default("staff") // "staff", "manager", "admin"
  permissions           String?  // JSON string for custom permissions
  isActive              Boolean  @default(true)
  joinedAt              DateTime @default(now())
  
  tenant                Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([tenantId, userId])
}

model TenantStore {
  id                    String   @id @default(cuid())
  tenantId              String
  storeId               String
  settings              String?  // JSON string for store-specific settings
  isActive              Boolean  @default(true)
  addedAt               DateTime @default(now())
  
  tenant                Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  store                 Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  @@unique([tenantId, storeId])
}

model TenantLicense {
  id                    String   @id @default(cuid())
  tenantId              String
  licenseId              String
  settings              String?  // JSON string for license-specific settings
  isActive              Boolean  @default(true)
  assignedAt            DateTime @default(now())
  expiresAt             DateTime?
  
  tenant                Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  license               License   @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  
  @@unique([tenantId, licenseId])
}

model Subscription {
  id                    String   @id @default(cuid())
  tenantId              String
  plan                  String
  status                String   @default("active") // "active", "cancelled", "expired", "suspended"
  billingCycle          String   @default("monthly") // "monthly", "yearly"
  amount                Float
  currency              String   @default("USD")
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime?
  trialEnd              DateTime?
  cancelledAt           DateTime?
  metadata              String?  // JSON string for additional data
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  tenant                Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

// Delivery Module Models
model DeliveryPerson {
  id            String   @id @default(cuid())
  name          String
  phone         String   @unique
  email         String?
  address       String?
  vehicleType   String   @default("motorcycle") // "motorcycle", "car", "bicycle", "walking"
  vehicleNumber String?
  licenseNumber String?
  status        String   @default("available") // "available", "busy", "offline", "on_leave"
  storeId       String
  hireDate      DateTime?
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  store         Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  deliveries    DeliveryOrder[]
}

model DeliveryArea {
  id          String   @id @default(cuid())
  name        String
  description String?
  storeId     String
  areaCode    String?  // Postal code or area code
  boundaries  String?  // JSON string for area boundaries
  deliveryFee Float    @default(0)
  minOrder    Float    @default(0)
  estimatedTime Int    @default(30) // in minutes
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  store       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  deliveries  DeliveryOrder[]
}

model DeliveryOrder {
  id              String   @id @default(cuid())
  orderId         String   @unique
  saleId          String   @unique
  storeId         String
  deliveryPersonId String?
  deliveryAreaId  String?
  customerName    String
  customerPhone   String
  customerEmail   String?
  deliveryAddress String
  deliveryNotes   String?
  deliveryType    String   @default("home_delivery") // "home_delivery", "third_party", "in_store_pickup"
  deliveryFee     Float    @default(0)
  deliveryStatus  String   @default("pending") // "pending", "assigned", "out_for_delivery", "delivered", "cancelled", "failed"
  estimatedDelivery DateTime?
  actualDelivery  DateTime?
  assignedAt      DateTime?
  pickedUpAt      DateTime?
  deliveredAt     DateTime?
  cancelledAt     DateTime?
  cancellationReason String?
  thirdPartyName  String?  // For third-party delivery services
  thirdPartyTrackingId String?
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  sale            Sale           @relation(fields: [saleId], references: [id], onDelete: Cascade)
  store           Store          @relation(fields: [storeId], references: [id], onDelete: Cascade)
  deliveryPerson  DeliveryPerson? @relation(fields: [deliveryPersonId], references: [id])
  deliveryArea    DeliveryArea?  @relation(fields: [deliveryAreaId], references: [id])
  statusUpdates   DeliveryStatusUpdate[]
  deliveryReports DeliveryReport[]
}

model DeliveryStatusUpdate {
  id              String   @id @default(cuid())
  deliveryOrderId String
  status          String   // "pending", "assigned", "out_for_delivery", "delivered", "cancelled", "failed"
  notes           String?
  location        String?  // JSON string with lat/lng
  updatedBy       String   // User ID or system
  updatedAt       DateTime @default(now())
  
  deliveryOrder   DeliveryOrder @relation(fields: [deliveryOrderId], references: [id], onDelete: Cascade)
}

model DeliveryReport {
  id              String   @id @default(cuid())
  deliveryOrderId String
  reportType      String   // "daily", "weekly", "monthly", "performance"
  metrics         String   // JSON string with report metrics
  generatedAt     DateTime @default(now())
  
  deliveryOrder   DeliveryOrder @relation(fields: [deliveryOrderId], references: [id], onDelete: Cascade)
}

// E-commerce Integration Models
model EcommercePlatform {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  website     String?
  apiVersion  String
  isActive    Boolean  @default(true)
  configTemplate String // JSON string for config template
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  stores      EcommerceStore[]
}

model EcommerceStore {
  id           String   @id @default(cuid())
  name         String
  platformId   String
  storeUrl     String
  apiKey       String
  apiSecret    String?
  config       String   // JSON string for additional config
  isActive     Boolean  @default(true)
  lastSyncAt   DateTime?
  syncStatus   String   @default("idle") // "idle", "syncing", "success", "error"
  syncError    String?
  autoSync     Boolean  @default(true)
  syncInterval Int      @default(30) // in minutes
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  platform     EcommercePlatform @relation(fields: [platformId], references: [id])
  products     EcommerceProduct[]
  orders       EcommerceOrder[]
  syncLogs     EcommerceSyncLog[]
  webhooks     EcommerceWebhook[]
}

model EcommerceProduct {
  id                String   @id @default(cuid())
  storeId           String
  productId         String   // Reference to POS product
  ecommerceProductId String   // Platform-specific product ID
  sku               String
  name              String
  description       String?
  price             Float
  comparePrice      Float?
  cost              Float?
  quantity          Int      @default(0)
  images            String   // JSON array of image URLs
  categories        String   // JSON array of category names
  tags              String   // JSON array of tags
  variants          String   // JSON string for variants
  status            String   @default("active") // "active", "draft", "archived"
  visibility        String   @default("visible") // "visible", "hidden"
  seoTitle          String?
  seoDescription    String?
  weight            Float?
  dimensions        String?  // JSON string for dimensions
  lastSyncedAt      DateTime @default(now())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  store             EcommerceStore @relation(fields: [storeId], references: [id], onDelete: Cascade)
  product           Product        @relation(fields: [productId], references: [id])
}

model EcommerceOrder {
  id              String   @id @default(cuid())
  storeId         String
  orderId         String   // Platform-specific order ID
  orderNumber     String
  customerEmail   String
  customerPhone   String?
  customerName    String
  shippingAddress String   // JSON string for address
  billingAddress  String   // JSON string for address
  items           String   // JSON string for order items
  subtotal        Float    @default(0)
  tax             Float    @default(0)
  shipping        Float    @default(0)
  discount        Float    @default(0)
  total           Float    @default(0)
  currency        String   @default("USD")
  status          String   @default("pending") // "pending", "processing", "shipped", "delivered", "cancelled", "refunded"
  paymentStatus   String   @default("pending") // "pending", "paid", "failed", "refunded"
  paymentMethod   String?
  trackingNumber  String?
  notes           String?
  saleId          String?  @unique  // Reference to POS sale if imported
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  store           EcommerceStore @relation(fields: [storeId], references: [id], onDelete: Cascade)
  sale            Sale?          @relation(fields: [saleId], references: [id])
}

model EcommerceSyncLog {
  id             String   @id @default(cuid())
  storeId        String
  type           String   // "product", "order", "inventory", "full"
  status         String   @default("pending") // "pending", "running", "success", "error"
  startTime      DateTime @default(now())
  endTime        DateTime?
  itemsProcessed Int      @default(0)
  itemsSuccess   Int      @default(0)
  itemsError     Int      @default(0)
  errorMessage   String?
  details        String?  // JSON string for additional details
  createdAt      DateTime @default(now())
  
  store          EcommerceStore @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model EcommerceWebhook {
  id             String   @id @default(cuid())
  storeId        String
  topic          String
  endpoint       String
  secret         String?
  isActive       Boolean  @default(true)
  lastTriggeredAt DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  store          EcommerceStore @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model AppSettings {
  id              String   @id @default("1")
  contactPhone    String   @default("01938264923")
  developerCredit String   @default("Developed by Halalzi")
  developerUrl    String?
  updatedByUserId String?
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())
  
  // Ensure only one row exists
  @@unique([id])
}